module Sieve (primesUpTo) where

-- You should not use any of the division operations when implementing
-- the sieve of Eratosthenes.
import Prelude hiding (div, mod, divMod, rem, quotRem, quot, (/))
import qualified Data.Map.Strict as M

primesUpTo :: Integer -> [Integer]
primesUpTo n
  | n < 2 = []
  | otherwise = takeWhile (<= n) primesStream

-- An infinite stream of prime numbers generated by the sieve.
primesStream :: [Integer]
primesStream = 2 : sieve [3, 5..] M.empty
  where
    -- `sieve` is the core of the algorithm.
    -- It takes a stream of candidate numbers and a map of composites.
    -- The map stores upcoming composite numbers as keys, and their
    -- prime factors as values.
    sieve :: [Integer] -> M.Map Integer [Integer] -> [Integer]
    sieve (x:xs) table =
      case M.lookup x table of
        -- If x is not in the table, it is a prime.
        Nothing ->
          -- Yield x, and mark its first composite multiple (x*x) in the table.
          x : sieve xs (M.insert (x*x) [x] table)
        -- If x is in the table, it is a composite.
        Just factors ->
          let -- Remove x from the table.
              table' = M.delete x table
              -- For each prime factor p of x, find the next odd multiple
              -- (x + 2*p) and add it to the table. `insertWith` handles
              -- cases where multiple factors mark the same composite.
              update_table t p = M.insertWith (++) (x + 2*p) [p] t
              new_table = foldr update_table table' factors
          in sieve xs new_table
    sieve [] _ = [] -- Unreachable with an infinite stream.
